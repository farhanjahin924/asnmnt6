<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PH blog</title>
     <!-- font -->
     <link rel="preconnect" href="https://fonts.googleapis.com" />
     <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
     <link
       href="https://fonts.googleapis.com/css2?family=Inter:wght@100;200;300;400;500;600;700;800;900&display=swap"
       rel="stylesheet"
     />
     <!-- daisy ui -->
    <link
      href="https://cdn.jsdelivr.net/npm/daisyui@3.6.4/dist/full.css"
      rel="stylesheet"
      type="text/css"
    />
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body{
            font-family: 'Inter', sans-serif;
        }
    </style>

</head>
<body class="bg-primary-content">
    <header>
        <header class="w-[90%] m-auto text-center content-center py-5  place-content-center">
            <nav>
              <div class="navbar ">
                <div class="navbar-start">
                    <h4 class="text-[#FF1F3D] text-4xl font-bold rounded-md">PH <span class="text-[#252525]">Blog</span></h4>
                </div>
               
                <div class="navbar-end">
                  <button onclick=" window.location.href = './index.html'" class="btn text-[#FFF] text-lg font-medium bg-[#FF1F3D] rounded-md" 
                  >HOME</button>
                </div>
              </div>
            </nav> 
            <hr class="border-black">
          </header> 
    </header>
   <main class="w-[90%] m-auto  content-center py-5  place-content-center gap-5">
    <div class="collapse collapse-arrow  ">
        <input type="radio" name="my-accordion-2" checked="checked" /> 
        <div class="collapse-title text-xl font-medium">
            The scope of var, let, and const : 
        </div>
        <div class="collapse-content"> 
          <p>
            var, let, and const are three keywords used for declaring variables in JavaScript, each with its own scope and behavior. These keywords have different rules regarding hoisting, redeclaration, and immutability, which affect their scope and usage:
            <br><br>
            1. var:

            
                <li>Function-scoped: Variables declared with var are function-scoped, meaning they are accessible within the function where they are defined.</li>
                <li>Hoisting: Variables declared with var are hoisted to the top of their containing function or global scope, which means you can access them before they are declared in code (although their value will be undefined).</li>
                <li>Redeclaration: You can redeclare a variable using var within the same scope without causing an error.</li>
                <li>Example : function example() {
                    var x = 10;
                    if (true) {
                      var x = 20; // Redeclaration within the same scope
                    }
                    console.log(x); // Outputs 20
                  }
                  </li>
            
            <br>
           
            2.Let :
            <li> Block-scoped: Variables declared with let are block-scoped, which means they are confined to the block (e.g., within loops or conditional statements) where they are defined.</li>
            <li>Hoisting: Variables declared with let are hoisted to the top of their containing block, but they are not initialized, so accessing them before declaration results in a ReferenceError.</li>
            <li>Redeclaration: You cannot redeclare a variable with the same name in the same scope using let.</li>
            <li>Example :function example() {
                let x = 10;
                if (true) {
                  let x = 20; // Block-scoped variable
                }
                console.log(x); // Outputs 10
              }
              </li>
           
            
            
            <br>
            
            3. const:
            <li> Redeclaration: You cannot redeclare a variable with the same name in the same scope using const</li>
            <li>Hoisting: Like let, const variables are hoisted to the top of their containing block but are not initialized.</li>
            <li> Immutability: Variables declared with const are constants and cannot be reassigned after their initial value is set. However, the value they hold can be mutable, e.g., for objects and arrays.</li>
            <li> Example :function example() {
                const x = 10;
                if (true) {
                  const x = 20; // Block-scoped constant
                }
                console.log(x); // Outputs 10
              }
              </li>

            
          
           
          </p>
        </div>
      </div>
      <div class="collapse collapse-arrow ">
        <input type="radio" name="my-accordion-2" /> 
        <div class="collapse-title text-xl font-medium">
            Use cases of null and undefined :
        </div>
        <div class="collapse-content"> 
          <p>
            In JavaScript, null and undefined are two distinct values that are often used to indicate the absence or unavailability of a value. While they are similar in some ways, they have different use cases: <br> <br>
            1. undefined:

            undefined is a primitive value in JavaScript that is automatically assigned to a variable that has been declared but has not been assigned a value.
            It is commonly used in the following scenarios: 
            <li>When a variable is declared but not initialized.
                
                
              </li>
            <li>When a function does not return a value explicitly (by default, it returns undefined).</li>
            <li>As a property of objects to indicate that the property does not exist.</li>
            <li>  As a parameter in a function that was not provided with an argument.</li>
            <li>Example : let x; // x is undefined

                function doSomething() {
                  // This function implicitly returns undefined
                }
                
                const obj = {};
                console.log(obj.nonExistentProperty); // undefined
                </li>
                <br>
            2. null:
                <li> null is a value in JavaScript that represents the intentional absence of any object value or a variable that has no value or has been explicitly set to null.</li>
                <li>It is typically used when you want to explicitly indicate that a variable or object property has no meaningful value.</li>
                <li>It can be useful in cases where you want to reset or clear a variable or object property.</li>
                <li>Example: let y = null; // y has no meaningful value

                    const person = {
                      name: "John",
                      address: null, // No address provided
                    };
                    </li>
           
            <br>
            In summary, undefined is often used to indicate that something has not been defined or initialized, whereas null is used to signify the intentional absence of a value or to clear a variable or object property. It's important to distinguish between these two values in your code to avoid unexpected behavior and make your code more expressive and self-documenting.
            
          </p>
        </div>
      </div>
      <div class="collapse collapse-arrow ">
        <input type="radio" name="my-accordion-2" /> 
        <div class="collapse-title text-xl font-medium">
            REST API:
        </div>
        <div class="collapse-content"> 
          <p>REST API stands for Representational State Transfer Application Programming Interface. It is a set of architectural principles and constraints used for designing networked applications. REST is not a specific technology or protocol but rather a style of designing web services that adhere to these principles. Here are the key characteristics and concepts of REST:
            <br>
            <br>
            <ol class="list-decimal pl-2 gap-1">
                <li>Statelessness: In a RESTful system, each request from a client to a server must contain all the information needed to understand and process the request. The server should not store any information about the client's state between requests. This makes the system highly scalable and easy to maintain.</li>
            <li>Resources: In REST, resources are the key abstractions. Resources are represented by URLs (Uniform Resource Locators) and can be anything that can be named, such as documents, images, or data records.</li>
            <li>HTTP Methods: RESTful APIs use HTTP methods (verbs) to perform CRUD (Create, Read, Update, Delete) operations on resources. The most commonly used HTTP methods in REST are:
                <ol class="list-inside">
                    <li>GET: Retrieve data from the server.</li>
                <li>POST: Create a new resource on the server.</li>
                <li>PUT: Update an existing resource or create a new resource if it doesn't exist.</li>
                <li>DELETE: Remove a resource from the server.</li>
                </ol>
            </li>
            <li>Uniform Interface: RESTful APIs should have a uniform and consistent interface. This means that the same HTTP methods should be used consistently across resources, and resource URLs should follow a predictable pattern.</li>
            <li>Representation: Resources can have multiple representations, such as JSON, XML, or HTML. Clients interact with resources by exchanging representations. The server should include metadata in the response to describe the resource and how to interact with it.</li>
            <li>Stateless Communication: Each request from the client to the server should be self-contained, meaning it should include all the necessary information. There should be no reliance on previous requests or server-side state.</li>
            <li>Client-Server Architecture: REST separates the client and server into independent components that can evolve separately. This separation improves scalability and simplifies the architecture.</li>
            <li>Layered System: A RESTful architecture can be composed of multiple layers, with each layer responsible for a specific function. This allows for flexibility and scalability.</li>
            <li>Cacheability: Responses from the server can be explicitly marked as cacheable or non-cacheable, which can improve performance and reduce server load.</li>
            </ol>
           
           </p>
        </div>
      </div>
   </main>
</body>
</html>